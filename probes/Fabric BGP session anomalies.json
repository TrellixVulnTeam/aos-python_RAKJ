{
  "label": "Fabric BGP session anomalies",
  "processors": [
    {
      "inputs": {},
      "type": "service_data_collector",
      "name": "Collect BGP session state",
      "outputs": {
        "out": "bgp_session_state"
      },
      "properties": {
        "description": "intf.description or 'facing %s' % (s2.hostname or s2.label or s2.role)",
        "graph_query": "match(node('system', name='s1', system_id=not_none(), deploy_mode='deploy').out('hosted_interfaces').node('interface', name='intf', if_type='ip', ipv4_addr=not_none()).out('link').node('link').in_('link').node('interface', name='other_intf', ipv4_addr=not_none()).in_('hosted_interfaces').node('system', name='s2').where(lambda s2: s2.role == 'external_router' or s2.deploy_mode == 'deploy').ensure_different('s1', 's2'), node('domain', name='d1', domain_type='autonomous_system').out('composed_of_systems').node(name='s1'), node('domain', name='d2', domain_type='autonomous_system').out('composed_of_systems').node(name='s2'))",
        "service_name": "bgp",
        "system_id": "s1.system_id",
        "key": "(intf.ipv4_addr.split('/')[0], d1.domain_id, other_intf.ipv4_addr.split('/')[0], d2.domain_id, 'default', 'ipv4')",
        "enable_streaming": false,
        "peer_hostname": "s2.hostname"
      }
    },
    {
      "inputs": {
        "in": "bgp_session_state"
      },
      "type": "state_check",
      "name": "Inactive BGP sessions",
      "outputs": {
        "out": "bgp_session_down"
      },
      "properties": {
        "enable_streaming": false,
        "state": "['unknown', 'down', 'missing']",
        "raise_anomaly": true,
        "graph_query": []
      }
    }
  ]
}